# `Logger` 構造体について

- ヒープ
  - 比較的遅い、動的に確保、GCによって回収
- エスケープ解析
  - 変数がエスケープする = 変数へのポインタがスタックからヒープに退避する
- インライン展開
  - 呼び出し元に関数を展開させて関数呼び出しのオーバーヘッドをなくす
- 可変長引数
  - 関数の中ではスライスになるが、そのメモリはどこに確保される？ -> it dependsらしい
  - スライスは1つの要素がエスケープされると全体がエスケープされる (ヒープにいく)
- 直接呼び出しの時はインライン展開されるのでスタックにいく
  - interfaceを介しての呼び出しだと、スライスはヒープに確保される
  - これはちゃんとコード書いて確かめる
- 値を返すかポインタを返すか
  - loggerが内部でhandlerを持っていて、handlerがsync.Mutexを持っているのでポインタで返しているっぽい
  - https://tsujitaku50.hatenablog.com/entry/2017/08/20/211559
- まとめ
  - ポインタを返すとヒープに領域が確保されるが、直接呼び出しをしているのでインライン展開でスタックに確保されるようになっている
  - interfaceを返しての呼び出しはヒープに行っちゃうのでNG
  - https://najeira.blogspot.com/2013/10/go.html


